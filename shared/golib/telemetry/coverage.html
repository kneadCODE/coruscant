
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>telemetry: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kneadCODE/coruscant/shared/golib/telemetry/clone.go (100.0%)</option>
				
				<option value="file1">github.com/kneadCODE/coruscant/shared/golib/telemetry/http_tracing.go (0.0%)</option>
				
				<option value="file2">github.com/kneadCODE/coruscant/shared/golib/telemetry/init.go (80.0%)</option>
				
				<option value="file3">github.com/kneadCODE/coruscant/shared/golib/telemetry/logger.go (100.0%)</option>
				
				<option value="file4">github.com/kneadCODE/coruscant/shared/golib/telemetry/measure.go (95.5%)</option>
				
				<option value="file5">github.com/kneadCODE/coruscant/shared/golib/telemetry/otel_logs.go (90.0%)</option>
				
				<option value="file6">github.com/kneadCODE/coruscant/shared/golib/telemetry/otel_resource.go (100.0%)</option>
				
				<option value="file7">github.com/kneadCODE/coruscant/shared/golib/telemetry/otel_traces.go (90.5%)</option>
				
				<option value="file8">github.com/kneadCODE/coruscant/shared/golib/telemetry/record.go (83.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package telemetry

import "context"

// Clone returns a new context with the same logger as the original context.
func Clone(ctx context.Context) context.Context <span class="cov8" title="1">{
        newCtx := context.Background()
        newCtx = setLoggerInContext(newCtx, LoggerFromContext(ctx))
        return newCtx
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package telemetry

import (
        "net/http"
        "slices"
        "strings"

        "github.com/go-chi/chi/v5"
        "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
        semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
        "go.opentelemetry.io/otel/trace"
)

// HTTPServerTracingMiddleware returns an HTTP middleware that provides enhanced OpenTelemetry tracing
// with comprehensive HTTP semantic conventions including missing attributes like route patterns,
// request/response sizes, and additional network information.
func HTTPServerTracingMiddleware(excludePaths []string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return otelhttp.NewHandler(
                        next,
                        "",
                        otelhttp.WithMessageEvents(otelhttp.ReadEvents, otelhttp.WriteEvents),
                        otelhttp.WithSpanNameFormatter(spanNameFormatter),
                        otelhttp.WithFilter(func(r *http.Request) bool </span><span class="cov0" title="0">{
                                path := r.URL.Path
                                return !slices.Contains(excludePaths, path)
                        }</span>),
                )
        }
}

// Add enhanced span name formatter with Chi route pattern support and enrich with missing attributes
func spanNameFormatter(operation string, r *http.Request) string <span class="cov0" title="0">{
        span := trace.SpanFromContext(r.Context())
        if span == nil || !span.SpanContext().IsValid() </span><span class="cov0" title="0">{
                return operation
        }</span>

        <span class="cov0" title="0">enrichWithSyntheticUserAgentDetection(r, span)

        // Use existing operation if provided by OTEL
        if operation != "" </span><span class="cov0" title="0">{
                return operation
        }</span>

        // Try to get the Chi route pattern for better span grouping
        <span class="cov0" title="0">if rctx := chi.RouteContext(r.Context()); rctx != nil &amp;&amp; rctx.RoutePattern() != "" </span><span class="cov0" title="0">{
                // Use route pattern (e.g., "/api/users/{id}") for better aggregation
                operation = r.Method + " " + rctx.RoutePattern()
                span.SetAttributes(semconv.HTTPRoute(rctx.RoutePattern()))
        }</span> else<span class="cov0" title="0"> {
                // Fallback to actual path if no route pattern available
                operation = r.Method + " " + r.URL.Path
        }</span>

        <span class="cov0" title="0">return operation</span>
}

// enrichWithSyntheticUserAgentDetection detects if a User-Agent string indicates synthetic traffic
func enrichWithSyntheticUserAgentDetection(r *http.Request, span trace.Span) <span class="cov0" title="0">{
        ua := strings.ToLower(r.UserAgent())
        if ua == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Bot indicators (crawlers, scrapers, validators)
        <span class="cov0" title="0">botIndicators := []string{
                "bot", "crawler", "spider", "scraper", "scanner",
                "validator", "headless", "phantom", "selenium", "webdriver",
                "googlebot", "bingbot", "slurp", "duckduckbot",
                "facebookexternalhit", "twitterbot", "linkedinbot",
        }
        for _, b := range botIndicators </span><span class="cov0" title="0">{
                if strings.Contains(ua, b) </span><span class="cov0" title="0">{
                        span.SetAttributes(semconv.UserAgentSyntheticTypeBot)
                        return
                }</span>
        }

        // Test indicators (synthetic monitoring, load testing, probes)
        <span class="cov0" title="0">testIndicators := []string{
                "k6", "jmeter", "locust", "wrk", "ab", "synthetic",
                "pingdom", "grafanacloud/syntheticmonitoring",
                "googlehc", "healthchecker",
        }
        for _, t := range testIndicators </span><span class="cov0" title="0">{
                if strings.Contains(ua, t) </span><span class="cov0" title="0">{
                        span.SetAttributes(semconv.UserAgentSyntheticTypeTest)
                        return
                }</span>
        }

        // Custom smoke test header
        <span class="cov0" title="0">if r.Header.Get("X-Smoke-Test") == "true" </span><span class="cov0" title="0">{
                span.SetAttributes(semconv.UserAgentSyntheticTypeTest)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package telemetry

import (
        "context"
        "log"
        "os"
)

// InitTelemetry initializes telemetry systems and returns a context with telemetry configurations.
// The returned cleanup function should be called during application shutdown.
func InitTelemetry(ctx context.Context, mode Mode) (context.Context, func(context.Context), error) <span class="cov8" title="1">{
        log.SetOutput(os.Stdout)
        log.Println("Initializing telemetry")

        cleanupF := func(context.Context) </span>{<span class="cov0" title="0">}</span>

        // Create OTEL resource once
        <span class="cov8" title="1">resource, err := newResource(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, cleanupF, err
        }</span>

        // Initialize logger
        <span class="cov8" title="1">logger, loggerCleanup, err := newOTELSlogLogger(ctx, resource)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, cleanupF, err
        }</span>
        <span class="cov8" title="1">ctx = setLoggerInContext(ctx, logger)
        cleanupF = func(ctx context.Context) </span><span class="cov0" title="0">{
                loggerCleanup(ctx)
        }</span>

        // Initialize trace provider
        <span class="cov8" title="1">_, traceCleanup, err := newOTELTraceProvider(ctx, resource, mode)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, cleanupF, err
        }</span>

        // Combined cleanup function
        <span class="cov8" title="1">cleanupF = func(ctx context.Context) </span><span class="cov8" title="1">{
                traceCleanup(ctx)
                loggerCleanup(ctx)
        }</span>

        <span class="cov8" title="1">logger.InfoContext(ctx, "Telemetry initialization complete")

        return ctx, cleanupF, nil</span>
}

// Mode represents the telemetry/logging mode.
type Mode int

const (
        // ModeDev enables development logging (info level, text output).
        ModeDev Mode = iota
        // ModeDevDebug enables development logging with debug level.
        ModeDevDebug
        // ModeProd enables production logging (info level, JSON output).
        ModeProd
        // ModeProdDebug enables production logging with debug level.
        ModeProdDebug
)
</pre>
		
		<pre class="file" id="file3" style="display: none">package telemetry

import (
        "context"
        "log/slog"
)

// contextKey is a private type used as a key for storing logger in context
type contextKey struct{}

// loggerKey is the key used to store logger in context
var loggerKey = contextKey{}

// SetLoggerFieldsInContext returns a new context with a logger that has additional fields.
// This is useful for adding request-scoped fields like request_id, user_id, etc.
func SetLoggerFieldsInContext(ctx context.Context, args ...any) context.Context <span class="cov8" title="1">{
        logger := LoggerFromContext(ctx)
        if logger == nil </span><span class="cov8" title="1">{
                return ctx
        }</span>
        <span class="cov8" title="1">return setLoggerInContext(ctx, logger.With(args...))</span>
}

// LoggerFromContext retrieves the logger from the context, or returns nil if not present.
func LoggerFromContext(ctx context.Context) *slog.Logger <span class="cov8" title="1">{
        if logger, ok := ctx.Value(loggerKey).(*slog.Logger); ok </span><span class="cov8" title="1">{
                return logger
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// setLoggerInContext returns a new context with the given logger attached.
// This is typically called at the beginning of request handling to attach request-specific logging context.
func setLoggerInContext(ctx context.Context, logger *slog.Logger) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, loggerKey, logger)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package telemetry

import (
        "context"
        "fmt"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
)

// Measure starts a new span for measuring operation duration and attributes.
// Returns a context with the span and a finish function to end the span.
// Attributes are provided as key-value pairs where keys must be strings.
// Supported value types: string, int, int64, float64, bool. Other types are converted to strings.
// Usage: ctx, finish := Measure(ctx, "operation-name", "key1", value1, "key2", value2)
func Measure(ctx context.Context, operationName string, attrs ...any) (context.Context, func(error)) <span class="cov8" title="1">{
        // Get tracer from the global provider - this is the OTEL recommended approach
        tracer := otel.Tracer(instrumentationIdentifier)

        // Configure span start options
        opts := []trace.SpanStartOption{
                trace.WithSpanKind(trace.SpanKindInternal),
        }

        // Add attributes if provided (convert key-value pairs to OTEL attributes)
        if len(attrs) &gt; 0 &amp;&amp; len(attrs)%2 == 0 </span><span class="cov8" title="1">{
                var otelAttrs []attribute.KeyValue
                for i := 0; i &lt; len(attrs); i += 2 </span><span class="cov8" title="1">{
                        key, ok := attrs[i].(string)
                        if !ok </span><span class="cov8" title="1">{
                                continue</span> // Skip invalid key (must be string)
                        }

                        <span class="cov8" title="1">value := attrs[i+1]
                        switch v := value.(type) </span>{
                        case string:<span class="cov8" title="1">
                                otelAttrs = append(otelAttrs, attribute.String(key, v))</span>
                        case int:<span class="cov8" title="1">
                                otelAttrs = append(otelAttrs, attribute.Int(key, v))</span>
                        case int64:<span class="cov0" title="0">
                                otelAttrs = append(otelAttrs, attribute.Int64(key, v))</span>
                        case float64:<span class="cov8" title="1">
                                otelAttrs = append(otelAttrs, attribute.Float64(key, v))</span>
                        case bool:<span class="cov8" title="1">
                                otelAttrs = append(otelAttrs, attribute.Bool(key, v))</span>
                        default:<span class="cov8" title="1">
                                // For other types, convert to string
                                otelAttrs = append(otelAttrs, attribute.String(key, fmt.Sprintf("%v", v)))</span>
                        }
                }
                <span class="cov8" title="1">opts = append(opts, trace.WithAttributes(otelAttrs...))</span>
        }

        // Start the span - OTEL will automatically handle trace context propagation
        <span class="cov8" title="1">ctx, span := tracer.Start(ctx, operationName, opts...)

        return ctx, func(err error) </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        span.RecordError(err)
                }</span>
                <span class="cov8" title="1">span.End()</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package telemetry

import (
        "context"
        "fmt"
        "log/slog"
        "os"

        "go.opentelemetry.io/contrib/bridges/otelslog"
        "go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploggrpc"
        olog "go.opentelemetry.io/otel/sdk/log"
        "go.opentelemetry.io/otel/sdk/resource"
)

// newOTELSlogHandler creates a new slog logger that sends logs to OTEL.
func newOTELSlogLogger(ctx context.Context, res *resource.Resource) (*slog.Logger, func(context.Context), error) <span class="cov8" title="1">{
        var exporter olog.Exporter
        var err error

        // Validate required environment variables
        endpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
        if endpoint == "" </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("OTEL_EXPORTER_OTLP_ENDPOINT environment variable is required")
        }</span>

        <span class="cov8" title="1">slog.InfoContext(ctx, "Initializing OTEL gRPC logs exporter")

        // Configure OTLP options based on environment
        opts := []otlploggrpc.Option{
                otlploggrpc.WithEndpoint(endpoint),
                // No compression for local collector deployment (localhost/same-node)
                // Compression adds CPU overhead without network benefit for local collectors
        }

        // Check if insecure connection is requested (for local development)
        if os.Getenv("OTEL_EXPORTER_OTLP_INSECURE") == "true" </span><span class="cov8" title="1">{
                opts = append(opts, otlploggrpc.WithInsecure())
        }</span>

        <span class="cov8" title="1">exporter, err = otlploggrpc.New(ctx, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create OTEL gRPC log exporter: %w", err)
        }</span>
        <span class="cov8" title="1">slog.InfoContext(ctx, "Initialized OTEL gRPC logs exporter")

        // Configure batch processor optimized for local collector deployment
        batchProcessor := olog.NewBatchProcessor(exporter,
                // Balanced settings for local collector (low latency + reasonable throughput)
                olog.WithMaxQueueSize(1024),      // Moderate queue size for local deployment
                olog.WithExportMaxBatchSize(256), // Smaller batches for lower latency to local collector
        )
        logProvider := olog.NewLoggerProvider(
                olog.WithResource(res),
                olog.WithProcessor(batchProcessor),
        )

        handler := otelslog.NewHandler(
                instrumentationIdentifier,
                otelslog.WithLoggerProvider(logProvider),
        )

        logger := slog.New(handler)

        logger.InfoContext(ctx, "Initialized OTEL slog logger")

        return logger, func(ctx context.Context) </span><span class="cov8" title="1">{
                _ = logProvider.Shutdown(ctx)
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package telemetry

import (
        "context"
        "fmt"

        "go.opentelemetry.io/otel/sdk/resource"
)

// newResource creates an OTEL resource with auto-detected information.
func newResource(ctx context.Context) (*resource.Resource, error) <span class="cov8" title="1">{
        res, err := resource.New(
                ctx,
                resource.WithFromEnv(),
                resource.WithProcess(),
                resource.WithOS(),
                resource.WithContainer(),
                resource.WithHost(),
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create OTEL resource: %w", err)
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package telemetry

import (
        "context"
        "fmt"
        "os"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
)

// newOTELTraceProvider creates a new OTEL trace provider with the given resource and mode.
func newOTELTraceProvider(ctx context.Context, res *resource.Resource, mode Mode) (*trace.TracerProvider, func(context.Context), error) <span class="cov8" title="1">{
        RecordInfoEvent(ctx, "Initializing OTEL trace gRPC client")

        // Validate required environment variables
        endpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
        if endpoint == "" </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("OTEL_EXPORTER_OTLP_ENDPOINT environment variable is required")
        }</span>

        // Configure OTLP options based on environment
        <span class="cov8" title="1">opts := []otlptracegrpc.Option{
                otlptracegrpc.WithEndpoint(endpoint),
                // No compression for local collector deployment (localhost/same-node)
                // Compression adds CPU overhead without network benefit for local collectors
        }

        // Check if insecure connection is requested (for local development)
        if os.Getenv("OTEL_EXPORTER_OTLP_INSECURE") == "true" </span><span class="cov8" title="1">{
                opts = append(opts, otlptracegrpc.WithInsecure())
        }</span>

        <span class="cov8" title="1">exporter, err := otlptracegrpc.New(ctx, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create OTEL trace gRPC exporter: %w", err)
        }</span>
        <span class="cov8" title="1">RecordInfoEvent(ctx, "Initialized OTEL trace gRPC exporter")

        // Configure trace provider with appropriate sampling
        var sampler trace.Sampler
        switch mode </span>{
        case ModeDev, ModeDevDebug:<span class="cov8" title="1">
                // Sample all traces in development
                sampler = trace.AlwaysSample()</span>
        case ModeProd, ModeProdDebug:<span class="cov8" title="1">
                // Sample 10% of traces in production (could enhance with smart sampling)
                sampler = trace.ParentBased(trace.TraceIDRatioBased(0.1))</span>
        default:<span class="cov8" title="1">
                sampler = trace.AlwaysSample()</span>
        }

        // Configure trace provider optimized for local collector deployment
        <span class="cov8" title="1">traceProvider := trace.NewTracerProvider(
                trace.WithResource(res),
                trace.WithBatcher(exporter,
                        // Balanced settings for local collector (low latency + reasonable throughput)
                        trace.WithMaxQueueSize(1024),      // Moderate queue size for local deployment
                        trace.WithMaxExportBatchSize(256), // Smaller batches for lower latency to local collector
                ),
                trace.WithSampler(sampler),
        )

        // Set global trace provider
        otel.SetTracerProvider(traceProvider)

        RecordInfoEvent(ctx, "Initialized OTEL trace provider")

        return traceProvider, func(ctx context.Context) </span><span class="cov8" title="1">{
                _ = traceProvider.Shutdown(ctx)
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package telemetry

import (
        "context"
        "fmt"
        "time"

        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
)

// RecordDebugEvent logs a debug-level event if a logger is present in the context.
// It also adds the event to the active span if tracing is enabled.
func RecordDebugEvent(ctx context.Context, msg string, args ...any) <span class="cov8" title="1">{
        if logger := LoggerFromContext(ctx); logger != nil </span><span class="cov8" title="1">{
                logger.DebugContext(ctx, msg, args...)
        }</span>

        // Record event in active span if present with timestamp
        <span class="cov8" title="1">addSpanEvent(ctx, msg, args...)</span>
}

// RecordInfoEvent logs an info-level event if a logger is present in the context.
// It also adds the event to the active span if tracing is enabled.
func RecordInfoEvent(ctx context.Context, message string, args ...any) <span class="cov8" title="1">{
        if logger := LoggerFromContext(ctx); logger != nil </span><span class="cov8" title="1">{
                logger.InfoContext(ctx, message, args...)
        }</span>

        // Record event in active span if present with timestamp
        <span class="cov8" title="1">addSpanEvent(ctx, message, args...)</span>
}

// RecordErrorEvent logs an error-level event if a logger is present in the context.
// It also adds the error event to the active span if tracing is enabled.
func RecordErrorEvent(ctx context.Context, err error, args ...any) <span class="cov8" title="1">{
        if logger := LoggerFromContext(ctx); logger != nil </span><span class="cov8" title="1">{
                logger.ErrorContext(ctx, err.Error(), args...)
        }</span>

        // Record error event in active span if present
        <span class="cov8" title="1">if span := trace.SpanFromContext(ctx); span.IsRecording() </span><span class="cov8" title="1">{
                span.RecordError(err, trace.WithTimestamp(time.Now()))
                addSpanEvent(ctx, "error occurred", args...)
        }</span>
}

// addSpanEvent adds an event to the active span with the given message and attributes.
// This consolidates the repeated span event logic used across all record functions.
func addSpanEvent(ctx context.Context, message string, args ...any) <span class="cov8" title="1">{
        if span := trace.SpanFromContext(ctx); span.IsRecording() </span><span class="cov8" title="1">{
                attrs := make([]attribute.KeyValue, 0, len(args)/2)
                for i := 0; i &lt; len(args)-1; i += 2 </span><span class="cov8" title="1">{
                        if key, ok := args[i].(string); ok </span><span class="cov8" title="1">{
                                attrs = append(attrs, attribute.String(key, formatValue(args[i+1])))
                        }</span>
                }
                <span class="cov8" title="1">span.AddEvent(message, trace.WithTimestamp(time.Now()), trace.WithAttributes(attrs...))</span>
        }
}

// formatValue converts any value to a string representation suitable for tracing attributes
func formatValue(v any) string <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case string:<span class="cov8" title="1">
                return val</span>
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", val)</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", val)</span>
        case float32, float64:<span class="cov0" title="0">
                return fmt.Sprintf("%.2f", val)</span>
        case bool:<span class="cov0" title="0">
                return fmt.Sprintf("%t", val)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", val)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
